\documentclass[12pt]{report}

\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{courier}
\usepackage{setspace}
\usepackage{verbatim}
\usepackage{alltt}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\lstset{
  language=Java,
  basicstyle=\ttfamily,
  numbers=left,
  numberstyle=\tiny,
  %stepnumber=2,
  numbersep=10pt,
  tabsize=3,
  extendedchars=true,
  breaklines=true,
  keywordstyle= \footnotesize,
  commentstyle=\color{gray},
  frame=no,
  stringstyle=\ttfamily,
  showspaces=false,
  showtabs=false,
  xleftmargin=17pt,
  framexleftmargin=17pt,
  framexrightmargin=5pt,
  framexbottommargin=4pt,
  %backgroundcolor=\color{lightgray},
  showstringspaces=false
}

\lstloadlanguages{
         Java
 }

\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox[cmyk]{0.43, 0.35, 0.35,0.01}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

\renewcommand{\chaptername}{}

\begin{document}

\title{
\textbf{Fantasy League Object Oriented Development}\\
\textbf{(FLOOD)}\\
\begin{doublespace}
\end{doublespace}
\LARGE{Project Report}\\
{\normalsize \textit{COMS W4115: Programming Language \& Translators}}\\
{\normalsize \textbf{Team 9}}\\
\normalsize{\textbf{is}}
}

\begin{singlespace}
\author{
  Stephanie Aligbe\\
  \textit{\normalsize{System Tester}}\\
  \texttt{\small{sna2111@columbia.edu}}
  \and
  Elliot Katz\\
  \textit{\normalsize{Project Manager}}\\
  \texttt{\small{epk2102@columbia.edu}}
  \and
  Tam Le\\
  \textit{\normalsize{System Architect}}\\
  \texttt{\small{tvl2102@columbia.edu}}
  \and
  Dillen Roggensinger\\
  \textit{\normalsize{System Integrator}}\\
  \texttt{\small{der2127@columbia.edu}}
  \and
  Anuj Sampathkumaran\\
  \textit{\normalsize{Language Guru}}\\
  \texttt{\small{as4046@columbia.edu}}
}
\end{singlespace}

\date{May 10, 2011}

\maketitle

\doublespacing

\tableofcontents

\chapter{Introduction}

As defined on Wikipedia: \textit{fantasy sport (also known as \textbf{rotisserie}, \textbf{roto}, or \textbf{owner simulation}) is a game where participants act as owners to build a team that competes against other fantasy owners based on the statistics generated by the real individual players or teams of a professional sport.}

The popularity of fantasy sports has exploded in recent years. A 2007 study by the \textit{Fantasy Sports Trade Association (FSTA)} estimated  nearly 30 million people in the U.S. and Canada, ranging in age from 12 and above, participated in organized fantasy sports leagues. In comparison, an estimated 3 million people played in the early 1990s, swelling to 15 million by the early 2000s. This impressive growth looks to continue since the study revealed teenagers in both the U.S. and Canada play fantasy sports at a higher rate than the national average, with 13 percent of teens playing in the U.S. and 14 percent playing in Canada.

The FSTA study also estimated the spending habits and overall economic impact of fantasy sports players. Consumers engaging in this ever growing hobby spent \$800 million directly on fantasy sports products and an additional \$3 billion worth of related media products (such as DirecTV's NFL Sunday Ticket and satellite radio's coverage of MLB). Moreover, the growing popularity of fantasy sports is not restricted to North America alone. A recent 2008 study by a European-based market research company estimated the number of fantasy sports players in Britain range between 5.5 and 7.5 million and vary in age between 16-64, of which 80 percent participated in fantasy soccer.

Thus, the \textbf{FLOOD} programming language is targeted to address a specific problem domain: the creation of fantasy gaming league applications. From the ground up, the language is designed to make it as straitforward as possible for programmers to create fantasy gaming applications. This task will entail defining a league and its type (sports, financial markets, election polls, etc.), establish the rules of governance, enumerate the users/teams and individual league players, and set various other control parameters. 

In this sense, \textbf{FLOOD} is very much a ``high-level" and ``domain-specific" language. Such as \textbf{R} and \textbf{S} are languages designed specifically to perform statistics calculations, \textbf{SQL} for relational database queries, and \textbf{Mathematica} and \textbf{Maxima} for symbolic mathematics, \textbf{FLOOD} is dedicated to solving the particular problem of fantasy gaming. Given the ubiquity of fantasy sports as a recreational hobby for millions of people, the creation of a domain-specific language to attack this problem in a clear and concise native programming etymology, as opposed to the application of a general purpose language such as \textbf{C} and \textbf{Java}, is a challenging and worthwhile undertaking.

\chapter{A Quick Tutorial}

The goal of this tutorial is to jump into the \textbf{FLOOD} language by creating a simple fantasy league. We won't concern ourselves with implementation details just yet. The language is meant to be simple yet sufficiently extensible but the tutorial will not delve into the various features that make this possible. 

Experienced Java programmers will be familiar with most of the syntax since it is a subset of the popular C-like syntax. In certain instances we have opted to use Python style syntax for improved readability or Pascal syntax for ease of use. Where possible we compare and contrast a specific feature with Java, Python or some other language which comprise the main influence of \textbf{FLOOD}. 

Some examples which aren't strictly necessary for the sample program are included to clarify points of possible confusion. These are noted when used. Additionally, we repeat portions of the \textbf{FLOOD} standard library for ease of reading. The full library is included in the \textit{Reference Manual} and \textit{Appendix} where appropriate. Please be aware of the distinction made between programmer, the person actually writing a \textbf{FLOOD} program (most likely yourself if you are reading this), and \textit{User}, the end-user of the application (which could be thought of as a team entitity). Additionally, \textit{Player} refers to a player of the fantasy league, whether this is an actual person as in the case of a quarterback in football or a non-human entitity as is the case with \textit{AAPL} (Apple) in the stock market.

\section{Getting Started - The ``Hello World" Program}

\textbf{FLOOD} has a very specific application domain. It's goal is to create fantasy leagues and thus the ability to print to console is fruitless. However, the GUI will have a message box where messages can be displayed to the \textit{User}. \textbf{FLOOD} hides the details of the user-interface so the programmer can concentrate on the rules of their specific fantasy league. While the first simple program may seem more complicated than the simple Java ``hello world" example, most programs generally will not be any more elaborate than this case.

Since \textbf{FLOOD} is built on top of Java byte-code, the programmer will not need to worry about system compatibility issues. Heeding the eternal wisdom of Kernighan \& Ritchie, we also point out that compilation will only succeed if the programmer hasn't botched anything, such as missing characters, misspelled keywords, or some other mistake that can cause an error in compilation. 

Let's start by showing what the \textit{main} class will look like. Defining the \textit{main} class should look somewhat similar to those familiar with Python.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Sample.fld]
/*
* Define the league and configure various settings
*/
DefineLeague
	/* Set league parameters */
	Set LeagueName("Happy League");
	...
	...
	Set MinTeamSize(5);

/*
* Define custom functions
*/
DefineFunctions
	Void myFunction1(Str param1, Int param2)
	{
		...
		...
	}

	...

	Void myFunction2(Bool param1, Flt param2)
	{
		...
		...
	}
\end{lstlisting}
\end{singlespace}

Let's now review the notable differences between Python, Java and \textbf{FLOOD}. First,  the convention in \textbf{FLOOD} is to name each file with the \textit{.fld} extension. In addition, each file is a self-contained program and unlike Java, there is no ability to add separate classes. And the first letter of any keyword in \textbf{FLOOD} is capitalized.

The language was originally intended to be object-oriented in order to facilitate modularity and extensibility of code. However, due to the restricted time constraints imposed by the course loads of various team members, it was decided to reduce the scope of the language without losing the basic functionalities as originally promised. Therefore, the abilities to add classes and inherit from pre-existing libraries were left for a possible future iteration of the language. 

The entry point for a \textbf{FLOOD} program is to specify the \texttt{DefineLeague} keyword. Since there is no question of class scope within a file, code below this program block is considered part of the program while any code above (excluding comments, naturally) is in error. It is important to note the \texttt{DefineLeague} block is semantically equivalent to the \texttt{main} function in a standard Java program and all the parameters and settings specified within this block can be viewed as passing parameters via the constructor method in a Java program. Moreover, it is not possible to declare local variables here since meaningful computations do not exist in this section of a \textbf{FLOOD} program. 

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Defining the league and setting parameters]
/*
* Define the league and configure various settings
*/
DefineLeague
	/* Set league parameters */
	Set LeagueName("Happy League");
	Set MaxUser(10);
	Set MinUser(12);
	Set MaxTeamSize(10);
	Set MinTeamSize(5);
	
	/* Add Users */
	Add User("Eli");
	Add User("Dillen");
	Add User("Anuj");
	Add User("Tam");
	Add User("Steph");

	/* Add Actions */
	Add Action("Field Goal Attempt", -0.45);
	Add Action("Field Goal Made", 1.0);
	Add Action("Free Throw Attempt", -0.75);

	/* Add Players */
	Add Player("Lebron James", "forward");
	Add Player("Chris Bosh", "forward");
	Add Player("Dwyane Wade", "guard");
\end{lstlisting}
\end{singlespace}

Every \textbf{FLOOD} program implicitly instantiates a \textit{League} object. The \textit{League} object contains most of the other objects needed for the \textbf{FLOOD} program including \textit{User}, \textit{Player} and \textit{Action} lists.

For the minimum program it may be possible to leave the maximum and mininum user settings at their respective default values, but as an example we set them above. In order to change certain attributes of the \textit{League} use the \texttt{Set} keyword with the attribute to be changed. Additionally, to create new \textit{Users}, \textit{Actions} and \textit{Players} use the \texttt{Add} keyword. Since local variables can not be set in the \textit{League} definition, all attributes must be literals. Note that \textit{Users} and \textit{Players} are simply a \textit{string} representing a name while \texttt{Action} is a name-value pair consisting of the name of the \texttt{Action} and the value that will be added to a \textit{User's} points through that \texttt{Action}.

A \textbf{FLOOD} developer need not worry about passing any values to the back-end---\textbf{FLOOD} encapsulates passing the \textit{League} to the GUI and calling the GUI.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Defining functions]
/*
* Defining custom user functions
*/
DefineFunctions
	Void myFunction1(Str param1, Int param2)
	{
		...
		...
	}

	...

	Void myFunction2(Bool param1, Flt param2)
	{
		...
		...
	}
\end{lstlisting}
\end{singlespace}

Before custom functions can be defined, the keyword \texttt{DefineFunctions} must be specified. Certain \textbf{FLOOD} functions are built into the language and the compiler will check whether the programmer has overridden them. They are as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Predefined FLOOD functions]
Int draftFunction(int turn) {...}
Bool draftPlayer(User u, Player p) {...}
Bool trade(User u1, Player[] p1, User u2, Player[] p2) {...}
Bool dropPlayer(User u, Player p) {...}
\end{lstlisting}
\end{singlespace}

If one of the above-mentioned functions is defined in the source file, then \textbf{FLOOD} will simply use the programmer's defined function. However, if any of the functions were left out, then \textbf{FLOOD} will generate default code for them (*Note: the appendix has a full listing for reference). A function in \textbf{FLOOD} is similar to a method in Java or a function in C++. We call a function by using the function's name with an optional argument list in between mandatory parenthesis.

In the following example, assume the function was defined as:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Predefined FLOOD functions]
Int draftFunction(Int turn)
{
	/* Number of Users is 10 */
	Int currentTurn;
	currentTurn = turn % 10;
	Return currentTurn;
}
\end{lstlisting}
\end{singlespace}

There are several things to note in the above code snippet. \textbf{FLOOD} uses $/*\ldots*/$ comments similar to Java and can span multiple lines. Variables are declared before they are used and all variables are instantiated to default values. Using a variable that hasn't been instantiated will result in a logical error rather than a semantic error. All variable declarations must occur before any other code in the function body. 

A \texttt{Return} must only occur at the end of the function and must match the stated return type. In the example above, \texttt{currentTurn} is declared as an \texttt{Int} and then instantiated. Only following the rest of the production body does \texttt{currentTurn} gets returned.

A function can be called similarly to Java:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Function call]
draftFunction(10);
\end{lstlisting}
\end{singlespace}

or in an assignment:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Function call in an assignment]
Int a;
a = draftFunction(10);
\end{lstlisting}
\end{singlespace}

Hiding the GUI is one of the main features of \textbf{FLOOD}. There is no need to program any part of the user-interface. The GUI will know how to hook into the \textbf{FLOOD} source and connect the buttons on the interface to the actions defined by the programmer. The output will be a GUI window which will control the flow of the program and in turn, the flow will depend upon the user's interactions. For instance, the only way to update the scores of the \textit{Users} is by adding player-action files to the program. \textit{Player-Action} files would contain new statistics such as:
\begin{center}
\begin{singlespace}
\begin{tabular}{ l l }
LeBron James & 7 Rebound \\
Lebron James & 4 Assist \\
Carmelo Anthony & 5 Steal \\
Carmelo Anthony & 25 Point Scored
\end{tabular}
\end{singlespace}
\end{center}

This is everything needed to run a simple \textbf{FLOOD} program. This basketball league will mirror equivalent leagues in \textit{Yahoo! Sports} or \textit{ESPN Fantasy} without network connectivity. The minimum ``Hello World" program is included below:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Minimal FLOOD program to create a basektball fantasy league]
DefineLeague
	Set LeagueName("Basketball League");
	Add User("Anuj");
	Add User("Tam");
	Add Action("Field Goal", 2.0);
	Add Action("Rebound", 1.0);
	Add Player("Lebron James", "forward");
	Add Player("Kobe Bryant", "guard");
	Add Player("Dwight Howard", "center");
	Add Player("Kevin Durant", "forward");

DefineFunctions
 /* None declared */
\end{lstlisting}
\end{singlespace}

\section{Variables \& Arithmetic Expressions}

Just as any robust programming language requires a comprehensive computational model, \textbf{FLOOD} provides the user with a set of arithmetic expressions and variable types to work with. To use a variable and work with it, the variable must be declared before it is used for the first time. A declaration defines the properties of the variables. A declaration is of the form \textit{type} followed by the \textit{name} of the variable to be declared of that type.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Variable declarations]
/* variable declarations */
Int i;
Bool b;
Flt f = 1.2; /* ...assigning value at point of declaration */
Str s;

/* ...or assigning values at a later point. */
i = 1;
b = True;
f = 2.1;
s = "Hello World";
\end{lstlisting}
\end{singlespace}

Here, variables are declared before they are used. It's also possible to assign values to the variables in the declaration. An important distinction between \textbf{FLOOD} and a programming language like Java is the location of actual declaration which, as noted \textit{\textbf{must be at the top}} of the function body. Following the declarations, the variables can be used as needed. Note that there is no coercion between \texttt{Flt} and \texttt{Int} since \textbf{FLOOD} does not support implicit type coercions, as shown here:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Implicit type coersion is not supported]
Int i;
Flt f;
i = 2.0; /* Error since 2.0 is a Flt */
f = 1; /* Error since 1 is an Int */
\end{lstlisting}
\end{singlespace}

More examples of assignment expressions which will throw errors due to mismatch types:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=More errors due to mistmatch type declarations and assignments]
Int i;
Int f;
f = 1.0;
i = f / f; /* Error: Int used in a Flt expression */
\end{lstlisting}
\end{singlespace}

\textbf{FLOOD} offers the set of arithmetic expressions required to create a comprehensive fantasy league of the developer's choice. This set comprises of the standard addition, subtraction, multiplication, division and modulus operators. In addition, statements can include functions as in the case:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Function used in an arithmetic statement]
Int i;
i = someFunction() + 10 * 4; /* someFunction() returns an Int */
\end{lstlisting}
\end{singlespace}

The above code snippet provides a glimpse of the arithmetic capabilities of \textbf{FLOOD}. The `$+$', `$-$', `$/$', and `$*$' operators are binary operators and can be used to add, subtract, divide and multiply \texttt{Flt} (floats) and \texttt{Int} (integers).

\section{Loops \& Conditionals}

Creating a fantasy league in \textbf{FLOOD} can range from simple computations to complex algorithms involved in drafts. To facilitate the latter, a \textbf{FLOOD} developer has the choice of using loops to make life easier.

The syntax for the \textit{while} loop follows the standard convention:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=while loop]
While (total < 4)
{
	centers = centers + 1;
	guards = guards - centers;
	forwards = forwards / 2;
	total + 1;
};
\end{lstlisting}
\end{singlespace}

The \textit{while} loop operates as follows: the condition in parentheses is tested. If it is true (\texttt{total} less than 4), the body of the loop (the three statements enclosed in braces) is executed. Then the condition is checked again and if true, the body is executed again. When the test becomes false (\texttt{total} equals or exceeds 4) the loop ends and execution continues at the statement immediately following the loop. 

\textbf{FLOOD} provides the developer with a conditional in the form of the \textit{if} expression that is defined as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=If conditional]
If (position == "center")
{
	position = position + 1;
};
\end{lstlisting}
\end{singlespace}

Here, the program checks the condition enclosed in the bracket. If this condition is met (in this case, if the person's position is \texttt{center}, then the program executes the next statement. \textbf{FLOOD} also incorporates \textit{$if\ldots else$} conditional statements as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=If...Else conditional statement]
If (points > 100)
{
	trade = True;
}
Else
{
	trade = False;
};	
\end{lstlisting}
\end{singlespace}

If the first condition ($\texttt{points} > 100$) is not met, then the statement or statements enclosed in body of the \texttt{Else} condition will be executed i.e. assign \texttt{False} to the \texttt{trade} variable.

\section{Functions \& Scope}

As in countless other programming languages, \textbf{FLOOD} employs the concept of a function (also referred to as a method, subroutine, or procedure), a logical grouping of code within the larger program which carries out a specific task and is relatively independent of the rest of the code base. The idea of a function is analogous to the notion of the ``black box" when discussing the concept of encapsulation in object-oriented programming. For a well-designed function, the particulars of ``how" a the function performs its task(s) is not of critical importance and just knowing ``what" it does suffices. Functions can be ``called" or ``executed" any number of times and from within other functions. 

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Syntax of a FLOOD function]
Bool evaluate(User u, Player p)
{
	...
} 
\end{lstlisting}
\end{singlespace}

An important requirement to remember is that functions \textit{\textbf{must be defined before}} they are used, as shown here:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=A function must be defined before being called]
Bool function1()
{
	Return False;
} 

...

Bool function2()
{
	Return function1();
} 
\end{lstlisting}
\end{singlespace}

In this example, function \texttt{function1()} is defined before \texttt{function2()} and therefore can be used in the body of \texttt{function2()}. 

The scope of a variable is limited to the function it is declared in---\textit{\textbf{variables cannot be declared global}}. In order to modify variables between functions they must be passed as parameters to the specific functions.

\section{Users \& Players (Arrays)}

The types \texttt{User} and \texttt{Player} are specific to \textbf{FLOOD}. They can only be declared as a formal parameter in the argument lists of functions:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=User and Player declared in function argument list]
Bool draftPlayer(User u, Player p) {...}
Bool trade(User u1, Player[] p1, User u2, Player[] p2) {...}
Bool dropPlayer(User u, Player p) {...}
\end{lstlisting}
\end{singlespace}

The GUI knows to look for these specific functions and populate them correctly. It is possible to define custom functions that take \texttt{User} and \texttt{Player} as arguments, though \textbf{FLOOD} convention recommends against it. 

Within \textbf{FLOOD}, arrays exists only in the context of \texttt{User} and \texttt{Player}. Both types can be passed as single values or array types. The array declaration is similar to Java:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Passing User and Player arrays]
Bool trade(User u1, Player[] p1, User u2, Player[] p2) {...}
\end{lstlisting}
\end{singlespace}

Square brackets are placed after the type before the name of the variable. An array can be accessed in the body of the function using an \texttt{Int} index. Both of the examples below are correct:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Assessing array elements using index]
Int i = 5;
draft(a[1]);
draft(b[i]);
\end{lstlisting}
\end{singlespace}

\textbf{FLOOD} has a few built-in functions that give the programmer more flexibility in writing functions. The functions are associated with \texttt{Users} and \texttt{Players} and as such are included in this section. The first function \texttt{ArrayLength} simply returns the length of the array that is passed to it. Note that Python similarly uses this kind of syntax to find the length of a list. The other two functions \texttt{AddPlayer()} and \texttt{RemovePlayer()} are functions that alert the GUI to the addition or removal of a \texttt{Player} from a \texttt{User}. For the full list of functions, see the \textit{Reference Manual} section \textit{Function Calls}. The syntax is as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Some FLOOD utility functions and usage]
Int i;
i = ArrayLength(p);  /* Where p is an array of Players */
AddPlayer(u, p); /* Where u is a User and p is a Player */
RemovePlayer(u, p); /* Where u is a User and p is a Player */
\end{lstlisting}
\end{singlespace}

\section{Alert \& Error}

\textbf{FLOOD} programs are run through a GUI so print statements conform to this interface. As an alternative to print streams to a console, \textbf{FLOOD} allows the programmer to display boxes of text. There are two kinds of boxes, \textit{Alert} and \textit{Error}:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Launching Alert and Error message boxes]
Alert("Alert Box Title", "Alert message......");
Error("Error Box Title", "Error message......");
\end{lstlisting}
\end{singlespace}

Both message boxes have the same structure. The keyword \texttt{Alert} or \texttt{Error} must be followed by the standard parenthesis with two arguments. Both arguments must be of type \texttt{Str}. The first argument will be the box's title while the second argument will be the message body.

\chapter{Reference Manual}

\section{Introduction}

The following is a brief Reference Manual for the \textbf{FLOOD} language. The reference manual is based on the K \& R C manual which has for the most part inspired Java, the language \textbf{FLOOD} is based on. In certain instances, where there was no distinction between \textbf{FLOOD} and C, the C reference manual definition was used. Additionally, certain explanations were adapted from the Oracle (formerly Sun) online collection of tutorials.

Many parts of the manual should be familiar to the seasoned programmer. We were able to use \textbf{FLOOD} to experiment with ideas that have been born from our collective programming experience. 

We begin with a high level view of the structure of a \textbf{FLOOD} program. It is divided into two logical blocks. The program begins with the very first block which sets the attributes of the \textit{League}. This block needs to be present and is specified as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=DefineLeague]
/*
* Define the League and configure various settings
*/
DefineLeague
	/* Set League parameters */
	Set LeagueName("The League Name");
	...
	...
	Set MinTeamSize(5);
\end{lstlisting}
\end{singlespace}

In this block, various attributes and properties of the \textit{League} are set such as the name of the \textit{League}, the list of \textit{Users}, the list of \textit{Players}, etc. We enumerate the list of possible statements allowed in this block below:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Setting league name]
Set LeagueName("The League Name");
\end{lstlisting}
\end{singlespace}

The above statement sets the name of the \textit{League}.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Setting maximun number of Users]
Set MaxUser(10);
\end{lstlisting}
\end{singlespace}

Sets the a limit on the maximum number of \textit{Users} of the \textit{League}.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Setting minimum number of Users]
Set MinUser(2);
\end{lstlisting}
\end{singlespace}

Sets the a limit on the minimum number of \textit{Users} of the \textit{League}.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Setting maximum size of each team]
Set MaxTeamSize(10);
\end{lstlisting}
\end{singlespace}

Places a limit on the size of each \textit{User's} team.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Setting minimum size of each team]
Set MinTeamSize(2);
\end{lstlisting}
\end{singlespace}

The minimum number of players that need to be in a \textit{User's} team.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Adding a User]
Add User("Name of User");
\end{lstlisting}
\end{singlespace}

Adds a \texttt{User} to the \textit{League}.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Adding an Action]
Add Action("Name of Action", 10);
\end{lstlisting}
\end{singlespace}

Adds an \texttt{Action} to the \textit{League} and the number of points associated with it.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Adding a Player]
Add Player("Name of Player", "Position");	
\end{lstlisting}
\end{singlespace}

Adds the \texttt{Player} to the \textit{League} object, along with the position of that \texttt{Player}.

The next logical block comprises of defining functions and invoking functions within them if needed. This segment needs to begin with the \texttt{DefineFunctions} keyword as follows:

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Defining functions]
DefineFunctions
	Void myFunction1(Str param1, Int param2)
	{
		...
		...
	}

	...

	Flt myFunction2(Bool param1, Flt param2)
	{
		...
		...
	}
\end{lstlisting}
\end{singlespace}

The variables in a function have to be defined at the start of the function and a function needs to be defined before it can be invoked. 

\section{Lexical Conventions}

The first phase in the interpretation of the source files is to do a low-level lexical transformation transforming every line to a series of tokens to be compiled in a later stage.

\subsection{Tokens}

There are 5 different types of tokens that exist: identifiers, keywords, string literals, operators and separators. White space and new line are inherently ignored and are merely used as a means of making code legible.

\subsection{Comments}

The sequence of characters initially starting with $/*$ and ending with $*/$ disqualify any of the surrounded characters from the lexical tokenization. Comments do not nest or occur within literals. There are no single-line comments however a single-line comment can be simulated using the above sequence on a single-line.

\subsection{Identifiers}

An identifier is a sequence of characters and digits beginning with a character. Underscore is also considered a letter. Additionally, the language is case sensitive.

\subsection{Keywords}

The following words are reserved as keywords and may not be used as identifiers:

\begin{center}
\begin{tabular}{ | l | l | l | l | l | }
\hline
\texttt{DefineLeague} & \texttt{DefineFunctions} & \texttt{LeagueName} & \texttt{Set} & \texttt{Add}\\
\hline
\texttt{MaxTeamSize} & \texttt{MinTeamSize} & \texttt{Action} & \texttt{Return} & \texttt{Str}\\
\hline
\texttt{MaxUser} & \texttt{MinUser} & \texttt{User} & \texttt{True} & \texttt{False} \\
\hline
\texttt{AddPlayer} & \texttt{RemovePlayer} & \texttt{Player} & \texttt{Void} & \texttt{While} \\
\hline
\texttt{GetUserName} & \texttt{GetNumPlayers} & \texttt{GetPlayerName} & \texttt{If} & \texttt{Else} \\
\hline
\texttt{GetPlayerPosition} & \texttt{GetPlayerPoints} & \texttt{ArrayLength} & \texttt{Int} & \texttt{Flt}\\
\hline
\end{tabular}
\end{center}

\subsection{String Literals}

A character constant is a sequence of one or more characters enclosed in double quotes, as in ``$\ldots$" Character constants do not contain the ` character or newlines in order to represent them but rather use different escape characters. They are the following:

\begin{center}
\begin{tabular}{ l l l l l l }
newline & NL & \textbackslash{n} & backslash & \textbackslash & \textbackslash\textbackslash \\
horizontal tab & HT & \textbackslash{t} & double quote & `` & \textbackslash"
\end{tabular}
\end{center}

\section{Type Specifiers}

\textbf{FLOOD} supports the following datatypes:
\begin{itemize}
\item \texttt{Void}
\item \texttt{Flt}: A number with decimal values precise up to 6 decimal places.
\item \texttt{Int}: An integer number.
\item \texttt{Str}: A String of characters.
\item \texttt{Bool}: True/ False values.
\end{itemize}
\begin{alltt}\begin{singlespace}
         \textit{type-specifier:}
              \textit{\textbf{Void}}
              \textit{\textbf{Flt}}
              \textit{\textbf{Int}}
              \textit{\textbf{Str}}
              \textit{\textbf{Bool}}\end{singlespace}
\end{alltt}

\section{Syntax Notation}

\subsection{Variable Declaration}

Variables can be declared at the start of each function and must be declared before any statement. Variables can be either simply declared, or can be set to a value during definition as follows:

\begin{alltt}\begin{singlespace}
         \textit{variable-declaration:}
              \textit{type-specifier variable}
              \textit{type-specifier variable = value}\end{singlespace}
\end{alltt}

\subsection{Expressions}

\subsubsection{Primary Expressions}

Identifiers, constants, strings, or expressions in parentheses.

\begin{alltt}\begin{singlespace}
         \textit{primary-expression:}
            \textit{identifier}
            \textit{constant}
            \textit{string}
            \textit{( expression )}\end{singlespace}
\end{alltt}

\subsubsection{Arithmetic Expressions}

\textbf{FLOOD} supports the arithmetic expressions of addition, subtraction, multiplication, division and modulus.

The addition ($+$) ,subtraction ($-$), multiplication ($*$) and division ($/$) operators are left associative. The modulus ($\%$) operator is non-associative.

The result of the $+$ operator is the sum of the operands. A string may also be added to another string. In this manner, concatenation is performed where the result is a string containing the first operand and then the second beginning at the end of the first.

The result of the $-$ operator is the difference of the operands. A string may not be subtracted from another string.

Multiplication and division can be performed only on \texttt{Int} and \texttt{Flt} types. Additionally, \textbf{FLOOD} does not enforce coercion of operand types. This means that any of the above operations can be performed only on operands of the same type. For example, an \texttt{Int} var added to an \texttt{Int} var.

\subsubsection{Relational Expressions}

The relational operators group left-to-right. The relational expression returns a boolean value.

\begin{alltt}\begin{singlespace}
         \textit{relational-expression:}
            \textit{variable < variable or constant}
            \textit{variable > variable or constant}
            \textit{variable <= variable or constant}
            \textit{variable >= variable or constant}
            \textit{variable == variable or constant}
            \textit{variable != variable or constant}
            (relational-expression)\end{singlespace}
\end{alltt}

The operators ($==$) and ($!$$=$) have lower precedence than the operators ($<$), ($>$), ($<=$), ($>=$).

\subsubsection{Boolean Expressions}

The three basic operators involved in boolean expressions are boolean \textit{AND} ($\&\&$), boolean \textit{OR} ($||$) and boolean \textit{NOT} ($!$). The \textit{AND} and \textit{OR} operators group left-to-right. The \textit{NOT} operator is right associative. The \textit{AND} operator returns true if both operands compared are true, and false otherwise. The \textit{OR} operator returns true if atleast one operand is true, and false otherwise. The \textit{NOT} operator returns true if the operand evaluates to false, and false otherwise.

\begin{alltt}\begin{singlespace}
         \textit{boolean-expression:}
            \textit{boolean-expression && boolean-expression}
            \textit{boolean-expression || boolean-expression}
            \textit{relational-expression && relational-expression}
            \textit{relational-expression || relational-expression}
            \textit{relational-expression && boolean-expression}
            \textit{relational-expression || boolean-expression}
            \textit{boolean-expression && relational-expression}
            \textit{boolean-expression || relational-expression}
            \textit{! boolean-expression}
            (boolean-expression)\end{singlespace}
\end{alltt}

\subsection{Function Declaration}

\textbf{FLOOD} allows the user to declare their own functions in addition to the default functions provided as follows:

\begin{alltt}\begin{singlespace}
         \textit{function-declaration:}
            \textit{returnType functionName (argumentList)
            \{
                statements
            \}}\end{singlespace}
\end{alltt}

Now the function \texttt{\textit{functionName}} can be invoked by any other function succeeding it in the program. It is important to note that the user needs to declare the function before invoking it.
Another point worth noting is that all variables need to be declared at the start of the function declaration before they can be used. 

\subsection{Statements}

Statements in \textbf{FLOOD} encompass conditionals, loops, assignments and function calls. Every statement needs to be succeeded by a semicolon.

\subsubsection{Conditionals}

A conditional statement in \textbf{FLOOD} is an statement which checks for a certain condition and processes the succeeding statements depending on the boolean value of the condition evaluated. The syntax is as follows:

\begin{alltt}\begin{singlespace}
            \textit{If (expression)
            \{
                statements
            \};}

            \textit{If (expression)
            \{
                statements
            \}
            Else
            \{
                statements
            \};}\end{singlespace}
\end{alltt}

Here, \textit{\texttt{expression}} can be a boolean expression or relational expression. If the value of the expression evaluates to \texttt{True}, then the statement is evaluated, otherwise control is passed to the next statement.

\subsubsection{Loops}

\textbf{FLOOD} provides the user with a looping structure in the form of the \textit{while} loop. The syntax is as follows:

\begin{alltt}\begin{singlespace}
            \textit{While (expression)
            \{
                statements
            \};}\end{singlespace}
\end{alltt}

Here, \textit{\texttt{expression}} can be either a relational expression or boolean expression. In the \textit{while} body, \textit{\texttt{statements}} is executed repeatedly as long as value of \textit{\texttt{expression}} remains true. The \textit{\texttt{expression}} must have boolean type.

\subsubsection{Function Calls}

The programmer can invoke functions at any point in the \texttt{DefineFunctions} scope as long as the function has been declared before the function call. 

\begin{alltt}\begin{singlespace}
            \textit{functionName(parameterList);}\end{singlespace}
\end{alltt}

There are additionally a number of built-in functions the users can invoke without needing to define them:

\begin{alltt}\begin{singlespace}
            \textit{AddPlayer(user, player);}\end{singlespace}
\end{alltt}

This function adds the \texttt{Player} object \textit{\texttt{player}} to the \texttt{User} object \textit{\texttt{user}}.

\begin{alltt}\begin{singlespace}
            \textit{RemovePlayer(user, player);}\end{singlespace}
\end{alltt}

This function removes the \texttt{Player} object \textit{\texttt{player}} to the \texttt{User} object \textit{\texttt{user}}.

\begin{alltt}\begin{singlespace}
            \textit{Int ArrayLength(user, player);}\end{singlespace}
\end{alltt}

This function takes as an argument either a \texttt{User} or \texttt{Player} \textit{\texttt{array}} object as the parameter and returns the length of the array.

\begin{alltt}\begin{singlespace}
            \textit{Str GetUserName(user);}\end{singlespace}
\end{alltt}

Retuns the name of the \texttt{User} object \textit{\texttt{user}}.

\begin{alltt}\begin{singlespace}
            \textit{Int GetNumPlayers(user);}\end{singlespace}
\end{alltt}
     
Returns the number of players of the \texttt{User} object \textit{\texttt{user}}.

\begin{alltt}\begin{singlespace}
            \textit{Str GetPlayerName(player);}\end{singlespace}
\end{alltt}

Returns the name of the \texttt{Player} object \textit{\texttt{player}}.

\begin{alltt}\begin{singlespace}
            \textit{Str GetPlayerPosition(player);}\end{singlespace}
\end{alltt}

Returns the postion of the \texttt{Player} object \textit{\texttt{player}}.

\begin{alltt}\begin{singlespace}
            \textit{Flt GetPlayerPoints(player);}\end{singlespace}
\end{alltt}

Returns the points of the \texttt{Player} object \textit{\texttt{player}}.

\subsubsection{Assignments}

Values can be assigned to variables depending on their type. For example,  a \texttt{Bool} variable can be assigned a value of either \texttt{True} or \texttt{False}. Similarly, an \texttt{Int} variable can be assigned any integer value. 

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Assignments]
var1 = True; /* if var1 is of type Bool */
var2 = 1; /* if var2 is of type Int */
var3 = 1.0; /* if var3 is of type Flt */
var4 = "string"; /* f var4 is of type Str */
\end{lstlisting}
\end{singlespace}

Additionally, the return value of an invoked function can be assigned to a variable.

\begin{singlespace}
\begin{lstlisting}[language=Java,label=some-code,caption=Function assignment]
var5 = function(); /* if the return type of the function matches the data type of var5 */
\end{lstlisting}
\end{singlespace}

\section{Scope}

The scope to be considered while programming in \textbf{FLOOD} is lexical scope of a variable. Variables can only exist within a function, and need to be defined at the start of the function body. Therefore, the scope of a variable is limited to the function in which it is defined.

\section{Grammar}

Below is a recapitulation of the grammar that was given throughout the earlier parts of this \textit{Reference Manual}.

\begin{alltt}\begin{singlespace}
     \textit{program: definitions functions}

     \textit{definitions: DefineLeague definitionlist}

     \textit{definitionlist: definitionlist definitionproductions}
          \textit{empty}
          
     \textit{definitionproductions:}
          \textit{Set LeagueName ( string-constant )}
          \textit{Set MaxUser ( int )}
          \textit{Set MinUser ( int )}
          \textit{Set MaxTeamSize ( int )}
          \textit{Set MinteamSize ( int )}
          \textit{Add User ( string-constant )}
          \textit{Add Action ( string-constant, float )}
          \textit{Add Action ( string-constant, -float )}
          \textit{Add Player ( string-constant, string-constant )}

     \textit{functions: DefineFunctions functionProductions}

     \textit{functionProductions: functionProductions returnType
                          functionName ( argumentLists )
                          \{ declarations statements returnProduction \}}
          \textit{functionProductions returnType functionName ( argumentLists )
                              \{ empty \}}
          \textit{functionProductions returnType functionName ( argumentLists )
                              \{ empty statements returnProduction \}}
          \textit{functionProductions returnType functionName ( argumentLists )
                              \{ declarations empty returnProduction \}}
          \textit{empty}

     \textit{returnType:}
          \textit{\textbf{Void}}
          \textit{\textbf{Str}}
          \textit{\textbf{Bool}}
          \textit{\textbf{Int}}
          \textit{\textbf{Flt}}
          
     \textit{functionName: identifier}

     \textit{argumentLists: argumentLists , argumentList}
          \textit{argumentList}
          \textit{empty}
          
     \textit{argumentList: returnType identifier}
          \textit{User [ ] identifier}
          \textit{Player [ ] identifier}
          \textit{User identifier}
          \textit{Player identifier}

     \textit{statements: statements statement}
          \textit{statement}

     \textit{statement: conditionals}
          \textit{loop}
          \textit{relational-expression}
          \textit{assignment}
          \textit{functionCall}

     \textit{returnProduction: Return identifier}
          \textit{Return string-constant}
          \textit{Return int}
          \textit{Return float}
          \textit{empty}

     \textit{conditionals: If ( relational-expression ) \{ statements \}}
          \textit{If ( relational-expression ) \{ statements \} Else \{ statements \}}
          \textit{If ( relational-expression ) \{ empty \}}
          \textit{If ( relational-expression ) \{ empty \} Else \{ empty \}}
          \textit{If ( relational-expression ) \{ statements \} Else \{ empty \}}
          \textit{If ( relational-expression ) \{ empty \} Else \{ statements \}}
          \textit{If ( boolean-expression ) \{ statements \}}
          \textit{If ( boolean-expression ) \{ statements \} Else \{ statements \}}
          \textit{If ( boolean-expression ) \{ empty \}}
          \textit{If ( boolean-expression ) \{ empty \} Else \{ empty \}}
          \textit{If ( boolean-expression ) \{ statements \} Else \{ empty \}}
          \textit{If ( boolean-expression ) \{ empty \} Else \{ statements \}}

     \textit{loop: While ( relational-expression ) \{ statements \}}
          \textit{While ( relational-expression ) \{ empty \}}
          \textit{While ( boolean-expression ) \{ statements \}}
          \textit{While ( boolean-expression ) \{ empty \}}

     \textit{declarations: declarations declaration}
          \textit{declaration}

     \textit{declaration: Flt identifier}
          \textit{Int identifier}
          \textit{Bool identifier}
          \textit{Str identifier}
          \textit{Flt identifier = float}
          \textit{Int identifier = integer}
          \textit{Bool identifier = True}
          \textit{Bool identifier = False}
          \textit{Str identifier = string-constant}

     \textit{relational-expression: identifier <= constant-or-variable}
          \textit{identifier >= constant-or-variable}
          \textit{identifier != constant-or-variable}
          \textit{identifier < constant-or-variable}
          \textit{identifier > constant-or-variable}
          \textit{identifier == constant-or-variable}
          \textit{( relational-expression )}

     \textit{boolean-expression: boolean-expression AND boolean-expression}
          \textit{boolean-expression OR boolean-expression}
          \textit{relational-expression AND relational-expression}
          \textit{relational-expression OR relational-expression}
          \textit{relational-expression AND boolean-expression}
          \textit{relational-expression OR boolean-expression}
          \textit{boolean-expression AND relational-expression}
          \textit{boolean-expression OR relational-expression}
          \textit{( boolean-expression )}
          \textit{! boolean-expression}
          \textit{identifier}
          \textit{True}
          \textit{False}

     \textit{constant-or-variable: float}
          \textit{integer}
          \textit{identifier}
          
     \textit{arithmetic-expression: arithmetic-expression PLUS
                            arithmetic-expression}
          \textit{arithmetic-expression MINUS arithmetic-expression}
          \textit{arithmetic-expression MULT arithmetic-expression}
          \textit{arithmetic-expression DIV arithmetic-expression}
          \textit{arithmetic-expression MOD arithmetic-expression}
          \textit{( arithmetic-expression )}
          \textit{identifier}
          \textit{float}
          \textit{integer}

     \textit{assignment: leftSide = rightSide}

     \textit{leftSide: identifier}

     \textit{rightSide: arithmetic-expression}
          \textit{functionCall}
          \textit{string-constant}
          \textit{True}
          \textit{False}

     \textit{functionCall: functionName ( parameterList )}
          \textit{AddPlayer ( identifier , identifier )}
          \textit{RemovePlayer ( identifier , identifier )}
          \textit{ArrayLength ( identifier )}
          \textit{GetUserName (identifier)}
          \textit{GetNumPlayers (identifier)}
          \textit{GetPlayerName (identifier)}
          \textit{GetPlayerPosition (identifier)}
          \textit{GetPlayerPoints (identifier)}

     \textit{parameterList: parameterList , parameterList}
          \textit{identifier}
          \textit{integer}
          \textit{float}
          \textit{string-constant}
          \textit{identifier [ integer ]}
          \textit{identifier [ identifier ]}

     \textit{empty:}
\end{singlespace}
\end{alltt}

%\chapter{Project Plan}
%
%\chapter{Language Evolution}
%
%\chapter{Language Architecture}
%
%\chapter{Development Enviornment}
%
%\chapter{Testing}
%
%\chapter{Conclusions}
%
%\section{Lessons Learned as a Team}
%
%\section{Lessons Learned by Team Members}
%
%\subsection{Stephanie Aligbe}
%
%\subsection{Elliot Katz}
%
%\subsection{Tam Le}
%
%\subsection{Dillen Roggensinger}
%
%\subsection{Anuj Sampathkumaran}
%
%\section{Advice for Future Teams}
%
%\section{Suggestions for Future Improvement}
%
%\appendix
%\chapter{FLOOD Source Code}

\end{document}
